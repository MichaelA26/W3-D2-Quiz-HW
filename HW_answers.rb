CRUD Quiz
Use the solution to this afternoon's Property Tracker lab to answer the following questions.
Please write your answers under each question, push the file to GitHub, and submit in the usual way.

MVP Questions
In our Property Tracker application:

Q1. Where are we instantiating instances of the Property class?
In property.rb, lines 65, 75, 88, and 101.


Q2. Where are we defining the SQL that enables us to save the ruby Property object into the database?
In property.rb, line 65.

Q3. In console.rb, which lines modify the database?
Lines 4, 6, 15, and 24.


Q4. Why do we not define the id of a Property object at the point we instantiate it (‘new it up’)?
If there is any mistakes in the code and the code is re-run, there may be a different ID.


Q5. Where and how do we assign the id (that is generated by the database) to the ruby Property object?
In property.rb, in the save method which starts on line 16. In here we have connected to the database
and put our properties into it. In this score the IDs are assigned.


Q6. Why do we put a guard (an if clause) on the @id attribute in the constructor?
The guard stops the code breaking in incorrect values are inputted. I.e., stops
our code from being nuked.


Q7. Why are some of the CRUD actions represented by instance methods, and others by class methods?
It differs depending on what data needs to be altered/extracted.


Q8. What type of data structure is returned by calls to db.exec_prepared()?
In the save method, how do we access the id from the returned data structure?
The table is returned. The id is returned on line 29.


Q9. Why do we use prepared statements when performing database operations?
It is a streamlined way to navigate the database.


Extension Questions
Look at the find_by_id and find_by_address methods in the Property class.

Q10. What do they take in as their arguments?
Options.

Q11. What are their return values?
The hashes (I.e. @id, @address etc)
